"""
Database models for NoteHelper application.
All SQLAlchemy models and association tables.
"""
from datetime import datetime, timezone, date
from typing import Optional
from flask_sqlalchemy import SQLAlchemy

# This will be initialized by the app factory
db = SQLAlchemy()


def utc_now():
    """Return current UTC time with timezone info."""
    return datetime.now(timezone.utc)


def get_single_user():
    """Get the single default user for single-user mode."""
    return User.query.first()


# =============================================================================
# Association Tables
# =============================================================================

# Association table for many-to-many relationship between CallLog and Topic
call_logs_topics = db.Table(
    'call_logs_topics',
    db.Column('call_log_id', db.Integer, db.ForeignKey('call_logs.id'), primary_key=True),
    db.Column('topic_id', db.Integer, db.ForeignKey('topics.id'), primary_key=True)
)

# Association table for many-to-many relationship between CallLog and Partner
call_logs_partners = db.Table(
    'call_logs_partners',
    db.Column('call_log_id', db.Integer, db.ForeignKey('call_logs.id'), primary_key=True),
    db.Column('partner_id', db.Integer, db.ForeignKey('partners.id'), primary_key=True)
)

# Association table for many-to-many relationship between CallLog and Milestone
call_logs_milestones = db.Table(
    'call_logs_milestones',
    db.Column('call_log_id', db.Integer, db.ForeignKey('call_logs.id'), primary_key=True),
    db.Column('milestone_id', db.Integer, db.ForeignKey('milestones.id'), primary_key=True)
)

# Association table for many-to-many relationship between Partner and Specialty
partners_specialties = db.Table(
    'partners_specialties',
    db.Column('partner_id', db.Integer, db.ForeignKey('partners.id'), primary_key=True),
    db.Column('specialty_id', db.Integer, db.ForeignKey('specialties.id'), primary_key=True)
)

# Association table for many-to-many relationship between Seller and Territory
sellers_territories = db.Table(
    'sellers_territories',
    db.Column('seller_id', db.Integer, db.ForeignKey('sellers.id'), primary_key=True),
    db.Column('territory_id', db.Integer, db.ForeignKey('territories.id'), primary_key=True)
)

# Association table for many-to-many relationship between Customer and Vertical
customers_verticals = db.Table(
    'customers_verticals',
    db.Column('customer_id', db.Integer, db.ForeignKey('customers.id'), primary_key=True),
    db.Column('vertical_id', db.Integer, db.ForeignKey('verticals.id'), primary_key=True)
)

# Association table for many-to-many relationship between SolutionEngineer and POD
solution_engineers_pods = db.Table(
    'solution_engineers_pods',
    db.Column('solution_engineer_id', db.Integer, db.ForeignKey('solution_engineers.id'), primary_key=True),
    db.Column('pod_id', db.Integer, db.ForeignKey('pods.id'), primary_key=True)
)


# =============================================================================
# User and Authentication Models
# =============================================================================

class User(db.Model):
    """User model for Entra ID (Azure AD) authentication.
    
    Supports multiple account types:
    - microsoft_azure_id: Corporate @microsoft.com account
    - external_azure_id: External tenant account (e.g., partner tenant)
    
    Users can log in with either account and will be associated with the same User record.
    Stub accounts are created when a new user attempts to link to an existing account.
    """
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    microsoft_azure_id = db.Column(db.String(255), unique=True, nullable=True)  # @microsoft.com Entra object ID
    external_azure_id = db.Column(db.String(255), unique=True, nullable=True)  # External tenant Entra object ID
    email = db.Column(db.String(255), nullable=False)  # Primary email (not necessarily unique if using both account types)
    microsoft_email = db.Column(db.String(255), nullable=True)  # Email from Microsoft account
    external_email = db.Column(db.String(255), nullable=True)  # Email from external account
    name = db.Column(db.String(255), nullable=False)
    is_admin = db.Column(db.Boolean, default=False, nullable=False)  # Admin flag for privileged users
    is_stub = db.Column(db.Boolean, default=False, nullable=False)  # True if this is a stub account awaiting linking
    linked_at = db.Column(db.DateTime, nullable=True)  # When the account linking was completed
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    last_login = db.Column(db.DateTime, default=utc_now, nullable=False)
    
    # User state properties (kept for compatibility)
    @property
    def is_authenticated(self):
        return True
    
    @property
    def is_active(self):
        return True
    
    @property
    def is_anonymous(self):
        return False
    
    def get_id(self):
        return str(self.id)
    
    @property
    def account_type(self) -> str:
        """Return account type: 'microsoft', 'external', or 'dual'."""
        has_microsoft = self.microsoft_azure_id is not None
        has_external = self.external_azure_id is not None
        
        if has_microsoft and has_external:
            return 'dual'
        elif has_microsoft:
            return 'microsoft'
        elif has_external:
            return 'external'
        return 'unknown'
    
    def get_pending_link_requests(self):
        """Get all pending linking requests targeting this user's email."""
        return AccountLinkingRequest.query.filter_by(
            target_email=self.email,
            status='pending'
        ).order_by(AccountLinkingRequest.created_at.desc()).all()
    
    def __repr__(self) -> str:
        return f'<User {self.email}>'


class AccountLinkingRequest(db.Model):
    """Requests to link a stub account to an existing user account."""
    __tablename__ = 'account_linking_requests'
    
    id = db.Column(db.Integer, primary_key=True)
    requesting_user_id = db.Column(db.Integer, db.ForeignKey('users.id', ondelete='SET NULL'), nullable=True)  # The stub account (NULL after merge)
    target_email = db.Column(db.String(255), nullable=False)  # Email of the account to link to
    status = db.Column(db.String(20), default='pending', nullable=False)  # 'pending', 'approved', 'denied'
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    resolved_at = db.Column(db.DateTime, nullable=True)
    resolved_by_user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
    
    # Relationships
    requesting_user = db.relationship('User', foreign_keys=[requesting_user_id], backref='linking_requests_sent')
    resolved_by_user = db.relationship('User', foreign_keys=[resolved_by_user_id])
    
    def __repr__(self) -> str:
        return f'<AccountLinkingRequest from={self.requesting_user_id} to={self.target_email} status={self.status}>'


# =============================================================================
# Organizational Structure Models
# =============================================================================

class POD(db.Model):
    """POD (Practice Operating Division) - organizational grouping of territories and personnel."""
    __tablename__ = 'pods'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(200), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False, default=1)
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    
    # Relationships
    territories = db.relationship('Territory', back_populates='pod', lazy='select')
    solution_engineers = db.relationship(
        'SolutionEngineer',
        secondary=solution_engineers_pods,
        back_populates='pods',
        lazy='select'
    )
    
    def __repr__(self) -> str:
        return f'<POD {self.name}>'


class SolutionEngineer(db.Model):
    """Solution Engineer (Azure Technical Seller) assigned to a POD with a specific specialty."""
    __tablename__ = 'solution_engineers'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(200), nullable=False)
    alias = db.Column(db.String(100), nullable=True)  # Microsoft email alias
    specialty = db.Column(db.String(50), nullable=True)  # Azure Data, Azure Core and Infra, Azure Apps and AI
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    
    # Relationships
    pods = db.relationship(
        'POD',
        secondary=solution_engineers_pods,
        back_populates='solution_engineers',
        lazy='select'
    )
    
    def __repr__(self) -> str:
        return f'<SolutionEngineer {self.name} ({self.specialty})>'
    
    def get_email(self) -> Optional[str]:
        """Get email address from alias."""
        if self.alias:
            return f"{self.alias}@microsoft.com"
        return None


class Vertical(db.Model):
    """Industry vertical for customer classification."""
    __tablename__ = 'verticals'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(200), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False, default=1)
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    
    # Relationships
    customers = db.relationship(
        'Customer',
        secondary=customers_verticals,
        back_populates='verticals',
        lazy='select'
    )
    
    def __repr__(self) -> str:
        return f'<Vertical {self.name}>'


class Territory(db.Model):
    """Geographic or organizational territory for organizing customers and sellers."""
    __tablename__ = 'territories'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(200), nullable=False)
    pod_id = db.Column(db.Integer, db.ForeignKey('pods.id'), nullable=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    
    # Relationships
    pod = db.relationship('POD', back_populates='territories')
    sellers = db.relationship(
        'Seller',
        secondary=sellers_territories,
        back_populates='territories',
        lazy='select'
    )
    customers = db.relationship('Customer', back_populates='territory', lazy='select')
    
    def __repr__(self) -> str:
        return f'<Territory {self.name}>'


class Seller(db.Model):
    """Sales representative who can be assigned to customers and call logs."""
    __tablename__ = 'sellers'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(200), nullable=False)
    alias = db.Column(db.String(100), nullable=True)  # Microsoft email alias
    seller_type = db.Column(db.String(20), nullable=False, default='Growth')  # Acquisition or Growth
    # Note: territory_id column kept for backwards compatibility but will be deprecated
    territory_id = db.Column(db.Integer, db.ForeignKey('territories.id'), nullable=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    
    # Relationships
    territories = db.relationship(
        'Territory',
        secondary=sellers_territories,
        back_populates='sellers',
        lazy='select'
    )
    customers = db.relationship('Customer', back_populates='seller', lazy='select')
    # Call logs can be accessed via Customer relationship
    
    def __repr__(self) -> str:
        return f'<Seller {self.name} ({self.seller_type})>'
    
    def get_email(self) -> Optional[str]:
        """Get email address from alias."""
        if self.alias:
            return f"{self.alias}@microsoft.com"
        return None


# =============================================================================
# Customer and Call Log Models
# =============================================================================

class Customer(db.Model):
    """Customer account that can be associated with call logs."""
    __tablename__ = 'customers'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(200), nullable=False)
    nickname = db.Column(db.String(200), nullable=True)
    tpid = db.Column(db.BigInteger, nullable=False)
    tpid_url = db.Column(db.String(500), nullable=True)
    notes = db.Column(db.Text, nullable=True)  # General notes for tracking opportunities/milestones
    territory_id = db.Column(db.Integer, db.ForeignKey('territories.id'), nullable=True)
    seller_id = db.Column(db.Integer, db.ForeignKey('sellers.id'), nullable=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    
    # Relationships
    seller = db.relationship('Seller', back_populates='customers')
    territory = db.relationship('Territory', back_populates='customers')
    call_logs = db.relationship('CallLog', back_populates='customer', lazy='select')
    verticals = db.relationship(
        'Vertical',
        secondary=customers_verticals,
        back_populates='customers',
        lazy='select'
    )
    
    def __repr__(self) -> str:
        return f'<Customer {self.name} ({self.tpid})>'
    
    def get_most_recent_call_date(self) -> Optional[datetime]:
        """Get the date of the most recent call log for this customer."""
        if not self.call_logs:
            return None
        most_recent = max(self.call_logs, key=lambda x: x.call_date)
        return most_recent.call_date
    
    def get_display_name_with_tpid(self) -> str:
        """Get customer name with TPID for display."""
        return f"{self.name} ({self.tpid})"
    
    def get_display_name(self) -> str:
        """Get customer name for display, using nickname if available."""
        return self.nickname if self.nickname else self.name
    
    def get_account_type(self) -> str:
        """Get account type (Acquisition/Growth) from assigned seller."""
        if self.seller:
            return self.seller.seller_type
        return "Unknown"


class Topic(db.Model):
    """Topic/technology that can be tagged on call logs."""
    __tablename__ = 'topics'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(200), nullable=False)
    description = db.Column(db.Text, nullable=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    
    # Relationships
    call_logs = db.relationship(
        'CallLog',
        secondary=call_logs_topics,
        back_populates='topics',
        lazy='select'
    )
    
    def __repr__(self) -> str:
        return f'<Topic {self.name}>'


class Specialty(db.Model):
    """Specialty area that can be associated with partners."""
    __tablename__ = 'specialties'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(200), nullable=False)
    description = db.Column(db.Text, nullable=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    
    # Relationships
    partners = db.relationship(
        'Partner',
        secondary=partners_specialties,
        back_populates='specialties',
        lazy='select'
    )
    
    def __repr__(self) -> str:
        return f'<Specialty {self.name}>'


class Partner(db.Model):
    """Partner organization that can be associated with call logs."""
    __tablename__ = 'partners'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(200), nullable=False)
    notes = db.Column(db.Text, nullable=True)
    rating = db.Column(db.Integer, nullable=True)  # 0-5 star rating, null = not rated
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    updated_at = db.Column(db.DateTime, default=utc_now, onupdate=utc_now, nullable=False)
    
    # Relationships
    contacts = db.relationship('PartnerContact', back_populates='partner', lazy='select', cascade='all, delete-orphan')
    specialties = db.relationship(
        'Specialty',
        secondary=partners_specialties,
        back_populates='partners',
        lazy='select'
    )
    call_logs = db.relationship(
        'CallLog',
        secondary=call_logs_partners,
        back_populates='partners',
        lazy='select'
    )
    
    def get_primary_contact(self):
        """Get the primary contact if one is designated."""
        for contact in self.contacts:
            if contact.is_primary:
                return contact
        return self.contacts[0] if self.contacts else None
    
    def __repr__(self) -> str:
        return f'<Partner {self.name}>'


class PartnerContact(db.Model):
    """Contact person at a partner organization."""
    __tablename__ = 'partner_contacts'
    
    id = db.Column(db.Integer, primary_key=True)
    partner_id = db.Column(db.Integer, db.ForeignKey('partners.id'), nullable=False)
    name = db.Column(db.String(200), nullable=False)
    email = db.Column(db.String(255), nullable=True)
    is_primary = db.Column(db.Boolean, default=False, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    
    # Relationships
    partner = db.relationship('Partner', back_populates='contacts')
    
    def __repr__(self) -> str:
        return f'<PartnerContact {self.name} at {self.partner.name if self.partner else "Unknown"}>'


class CallLog(db.Model):
    """Call log entry with rich text content and associated metadata."""
    __tablename__ = 'call_logs'
    
    id = db.Column(db.Integer, primary_key=True)
    customer_id = db.Column(db.Integer, db.ForeignKey('customers.id'), nullable=False)
    # DateTime for full timestamp - date portion for display, time for meeting imports
    call_date = db.Column(db.DateTime, nullable=False, default=lambda: datetime.now())
    content = db.Column(db.Text, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    updated_at = db.Column(db.DateTime, default=utc_now, onupdate=utc_now, nullable=False)
    
    # Relationships
    customer = db.relationship('Customer', back_populates='call_logs')
    topics = db.relationship(
        'Topic',
        secondary=call_logs_topics,
        back_populates='call_logs',
        lazy='select'
    )
    partners = db.relationship(
        'Partner',
        secondary=call_logs_partners,
        back_populates='call_logs',
        lazy='select'
    )
    milestones = db.relationship(
        'Milestone',
        secondary=call_logs_milestones,
        back_populates='call_logs',
        lazy='select'
    )
    
    @property
    def seller(self):
        """Get seller from customer relationship."""
        return self.customer.seller if self.customer else None
    
    @property
    def territory(self):
        """Get territory from customer relationship."""
        return self.customer.territory if self.customer else None
    
    def __repr__(self) -> str:
        return f'<CallLog {self.id} for {self.customer.name}>'


class Opportunity(db.Model):
    """Opportunity from MSX that groups milestones under a customer."""
    __tablename__ = 'opportunities'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # MSX identifiers
    msx_opportunity_id = db.Column(db.String(50), nullable=False, unique=True)  # GUID from MSX
    opportunity_number = db.Column(db.String(50), nullable=True)  # e.g., "7-3FU4Q45URI"
    name = db.Column(db.String(500), nullable=False)
    
    # Relationships
    customer_id = db.Column(db.Integer, db.ForeignKey('customers.id'), nullable=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    updated_at = db.Column(db.DateTime, default=utc_now, onupdate=utc_now, nullable=False)
    
    # Team membership
    on_deal_team = db.Column(db.Boolean, default=False, nullable=False, server_default='0')  # Am I on the opportunity deal team?
    
    # Relationships
    customer = db.relationship('Customer', backref=db.backref('opportunities', lazy='dynamic'))
    milestones = db.relationship('Milestone', back_populates='opportunity', lazy='dynamic')
    
    def __repr__(self) -> str:
        return f'<Opportunity {self.id}: {self.name[:50]}>'


class Milestone(db.Model):
    """Milestone from MSX sales platform that can be linked to call logs."""
    __tablename__ = 'milestones'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # MSX identifiers
    msx_milestone_id = db.Column(db.String(50), nullable=True, unique=True)  # GUID from MSX
    milestone_number = db.Column(db.String(50), nullable=True)  # e.g., "7-503412553"
    url = db.Column(db.String(2000), nullable=False)
    
    # Milestone details from MSX
    title = db.Column(db.String(500), nullable=True)  # msp_name from MSX
    msx_status = db.Column(db.String(50), nullable=True)  # "On Track", "Cancelled", etc.
    msx_status_code = db.Column(db.Integer, nullable=True)  # Numeric status code
    opportunity_name = db.Column(db.String(500), nullable=True)  # Parent opportunity name (legacy, kept for compat)
    
    # Milestone tracker fields (populated from MSX sync)
    due_date = db.Column(db.DateTime, nullable=True)  # Target completion date from MSX
    dollar_value = db.Column(db.Float, nullable=True)  # Estimated revenue/value from MSX
    workload = db.Column(db.String(200), nullable=True)  # Workload name from MSX
    monthly_usage = db.Column(db.Float, nullable=True)  # Monthly usage amount from MSX
    last_synced_at = db.Column(db.DateTime, nullable=True)  # Last time synced from MSX
    on_my_team = db.Column(db.Boolean, default=False, nullable=False, server_default='0')  # Am I on the milestone access team?
    
    # Relationships
    customer_id = db.Column(db.Integer, db.ForeignKey('customers.id'), nullable=True)
    opportunity_id = db.Column(db.Integer, db.ForeignKey('opportunities.id'), nullable=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    updated_at = db.Column(db.DateTime, default=utc_now, onupdate=utc_now, nullable=False)
    
    # Relationships
    customer = db.relationship('Customer', backref=db.backref('milestones', lazy='dynamic'))
    opportunity = db.relationship('Opportunity', back_populates='milestones')
    call_logs = db.relationship(
        'CallLog',
        secondary=call_logs_milestones,
        back_populates='milestones',
        lazy='select'
    )
    tasks = db.relationship('MsxTask', back_populates='milestone', lazy='dynamic')
    
    @property
    def display_text(self):
        """Return title if set, otherwise milestone number or default."""
        if self.title:
            return self.title
        if self.milestone_number:
            return self.milestone_number
        return 'View in MSX'
    
    @property
    def status_sort_order(self):
        """Return sort order for status (lower = more important)."""
        status_order = {
            'On Track': 1,
            'At Risk': 2,
            'Blocked': 3,
            'Completed': 4,
            'Cancelled': 5,
            'Lost to Competitor': 6,
            'Hygiene/Duplicate': 7,
        }
        return status_order.get(self.msx_status, 99)
    
    @property
    def is_active(self) -> bool:
        """Return True if milestone is in an active (uncommitted) status."""
        active_statuses = {'On Track', 'At Risk', 'Blocked'}
        return self.msx_status in active_statuses
    
    @property
    def due_date_urgency(self) -> str:
        """Return urgency level based on due date: 'past_due', 'this_week', 'this_month', 'future', 'no_date'."""
        if not self.due_date:
            return 'no_date'
        from datetime import datetime, timedelta, timezone
        now = datetime.now(timezone.utc)
        due = self.due_date if self.due_date.tzinfo else self.due_date.replace(tzinfo=timezone.utc)
        days_until = (due - now).days
        if days_until < 0:
            return 'past_due'
        elif days_until <= 7:
            return 'this_week'
        elif days_until <= 30:
            return 'this_month'
        else:
            return 'future'
    
    def __repr__(self) -> str:
        return f'<Milestone {self.id}: {self.title or self.milestone_number or self.url[:50]}>'


class MsxTask(db.Model):
    """Task created in MSX linked to a milestone and call log."""
    __tablename__ = 'msx_tasks'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # MSX identifiers
    msx_task_id = db.Column(db.String(50), nullable=False, unique=True)  # GUID from MSX
    msx_task_url = db.Column(db.String(2000), nullable=True)
    
    # Task details
    subject = db.Column(db.String(500), nullable=False)
    description = db.Column(db.Text, nullable=True)
    task_category = db.Column(db.Integer, nullable=False)  # Numeric code
    task_category_name = db.Column(db.String(100), nullable=True)  # Display name
    duration_minutes = db.Column(db.Integer, default=60, nullable=False)
    is_hok = db.Column(db.Boolean, default=False, nullable=False)  # Is this a HOK task?
    due_date = db.Column(db.DateTime, nullable=True)  # scheduledend from MSX
    
    # Relationships
    call_log_id = db.Column(db.Integer, db.ForeignKey('call_logs.id'), nullable=True)
    milestone_id = db.Column(db.Integer, db.ForeignKey('milestones.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    
    # Relationships
    call_log = db.relationship('CallLog', backref=db.backref('msx_tasks', lazy='dynamic'))
    milestone = db.relationship('Milestone', back_populates='tasks')
    
    def __repr__(self) -> str:
        return f'<MsxTask {self.id}: {self.subject[:50]}>'


# =============================================================================
# User Preferences Model
# =============================================================================

class UserPreference(db.Model):
    """User preferences including dark mode and customer view settings."""
    __tablename__ = 'user_preferences'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, nullable=False, default=1)  # Single user system
    dark_mode = db.Column(db.Boolean, default=False, nullable=False)
    customer_view_grouped = db.Column(db.Boolean, default=False, nullable=False)
    customer_sort_by = db.Column(db.String(20), default='alphabetical', nullable=False)  # 'alphabetical', 'grouped', or 'by_calls'
    topic_sort_by_calls = db.Column(db.Boolean, default=False, nullable=False)
    territory_view_accounts = db.Column(db.Boolean, default=False, nullable=False)  # False = recent calls, True = accounts
    colored_sellers = db.Column(db.Boolean, default=True, nullable=False)  # False = grey sellers, True = colored sellers
    show_customers_without_calls = db.Column(db.Boolean, default=True, nullable=False)  # False = hide customers with no calls, True = show all customers
    first_run_modal_dismissed = db.Column(db.Boolean, default=False, nullable=False)  # Track if welcome modal has been dismissed
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    updated_at = db.Column(db.DateTime, default=utc_now, onupdate=utc_now, nullable=False)
    
    def __repr__(self) -> str:
        return f'<UserPreference user_id={self.user_id} dark_mode={self.dark_mode} customer_view_grouped={self.customer_view_grouped} customer_sort_by={self.customer_sort_by} topic_sort_by_calls={self.topic_sort_by_calls} territory_view_accounts={self.territory_view_accounts} colored_sellers={self.colored_sellers} show_customers_without_calls={self.show_customers_without_calls} first_run_modal_dismissed={self.first_run_modal_dismissed}>'


# =============================================================================
# AI Features Models
# =============================================================================

class AIQueryLog(db.Model):
    """Audit log of all AI API calls for debugging and prompt improvement."""
    __tablename__ = 'ai_query_log'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    timestamp = db.Column(db.DateTime, default=utc_now, nullable=False)
    request_text = db.Column(db.Text, nullable=False)
    response_text = db.Column(db.Text, nullable=True)
    success = db.Column(db.Boolean, nullable=False)
    error_message = db.Column(db.Text, nullable=True)
    
    # Token and model tracking
    model = db.Column(db.String(100), nullable=True)
    prompt_tokens = db.Column(db.Integer, nullable=True)
    completion_tokens = db.Column(db.Integer, nullable=True)
    total_tokens = db.Column(db.Integer, nullable=True)
    
    # Relationship
    user = db.relationship('User', foreign_keys=[user_id])
    
    def __repr__(self) -> str:
        status = 'success' if self.success else 'failed'
        return f'<AIQueryLog user_id={self.user_id} {status} at {self.timestamp}>'


# =============================================================================
# Revenue Integration Models
# =============================================================================

class RevenueImport(db.Model):
    """Tracks each revenue data import from MSXI CSV."""
    __tablename__ = 'revenue_imports'
    
    id = db.Column(db.Integer, primary_key=True)
    filename = db.Column(db.String(500), nullable=False)
    imported_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    
    # Stats about this import
    record_count = db.Column(db.Integer, nullable=False, default=0)  # Customer/bucket rows in CSV
    new_months_added = db.Column(db.Integer, default=0)  # New month columns we hadn't seen
    records_updated = db.Column(db.Integer, default=0)  # Existing records updated
    records_created = db.Column(db.Integer, default=0)  # New records created
    
    # Month range in this import
    earliest_month = db.Column(db.Date, nullable=True)
    latest_month = db.Column(db.Date, nullable=True)
    
    # Relationships
    user = db.relationship('User', foreign_keys=[user_id])
    data_points = db.relationship('CustomerRevenueData', back_populates='last_import', lazy='select')
    
    def __repr__(self) -> str:
        return f'<RevenueImport {self.filename} at {self.imported_at}>'


class CustomerRevenueData(db.Model):
    """Monthly revenue data point for a customer/bucket combination.
    
    This is the RAW DATA layer - stores every customer's monthly revenue
    whether they're flagged for engagement or not. Accumulates over imports.
    """
    __tablename__ = 'customer_revenue_data'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # Customer identification (from CSV)
    customer_name = db.Column(db.String(500), nullable=False, index=True)
    tpid = db.Column(db.String(50), nullable=True, index=True)
    seller_name = db.Column(db.String(200), nullable=True)  # From territory alignment in CSV
    bucket = db.Column(db.String(50), nullable=False)  # Core DBs, Analytics, Modern DBs
    
    # Link to NoteHelper customer (nullable until matched)
    customer_id = db.Column(db.Integer, db.ForeignKey('customers.id'), nullable=True, index=True)
    
    # Month identifier
    fiscal_month = db.Column(db.String(20), nullable=False)  # e.g., "FY26-Jan" for display
    month_date = db.Column(db.Date, nullable=False, index=True)  # First of month, for sorting
    
    # Revenue value
    revenue = db.Column(db.Float, nullable=False, default=0.0)
    
    # Tracking
    first_imported_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    last_updated_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    last_import_id = db.Column(db.Integer, db.ForeignKey('revenue_imports.id'), nullable=False)
    
    # Relationships
    last_import = db.relationship('RevenueImport', back_populates='data_points')
    customer = db.relationship('Customer', backref='revenue_data_points')
    
    # Unique constraint: one record per customer/bucket/month
    __table_args__ = (
        db.UniqueConstraint('customer_name', 'bucket', 'month_date', name='uq_customer_bucket_month'),
        db.Index('ix_revenue_data_lookup', 'customer_name', 'bucket'),
    )
    
    def __repr__(self) -> str:
        return f'<CustomerRevenueData {self.customer_name} {self.bucket} {self.fiscal_month}: ${self.revenue:,.0f}>'


class ProductRevenueData(db.Model):
    """Monthly revenue data for a specific product within a customer/bucket.
    
    This provides drill-down capability - when a bucket is flagged for attention,
    you can see which specific products are driving the revenue changes.
    """
    __tablename__ = 'product_revenue_data'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # Customer/bucket identification
    customer_name = db.Column(db.String(500), nullable=False, index=True)
    bucket = db.Column(db.String(50), nullable=False)  # Core DBs, Analytics, Modern DBs
    product = db.Column(db.String(200), nullable=False, index=True)  # ServiceLevel4 from CSV
    
    # Link to NoteHelper customer (nullable until matched)
    customer_id = db.Column(db.Integer, db.ForeignKey('customers.id'), nullable=True, index=True)
    
    # Month identifier
    fiscal_month = db.Column(db.String(20), nullable=False)
    month_date = db.Column(db.Date, nullable=False, index=True)
    
    # Revenue value
    revenue = db.Column(db.Float, nullable=False, default=0.0)
    
    # Tracking
    first_imported_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    last_updated_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    last_import_id = db.Column(db.Integer, db.ForeignKey('revenue_imports.id'), nullable=False)
    
    # Relationships
    last_import = db.relationship('RevenueImport', backref='product_data_points')
    customer = db.relationship('Customer', backref='product_revenue_data_points')
    
    # Unique constraint: one record per customer/bucket/product/month
    __table_args__ = (
        db.UniqueConstraint('customer_name', 'bucket', 'product', 'month_date', name='uq_customer_bucket_product_month'),
        db.Index('ix_product_revenue_lookup', 'customer_name', 'bucket', 'product'),
        db.Index('ix_product_name', 'product'),
    )
    
    def __repr__(self) -> str:
        return f'<ProductRevenueData {self.customer_name} {self.bucket}/{self.product} {self.fiscal_month}: ${self.revenue:,.0f}>'


class RevenueAnalysis(db.Model):
    """Computed analysis for a customer/bucket - regenerated on demand or after import.
    
    This is the ANALYSIS layer - computed from CustomerRevenueData.
    Can be regenerated anytime from the raw data.
    """
    __tablename__ = 'revenue_analyses'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # Link to customer (by name for unmatched, by ID when matched)
    customer_name = db.Column(db.String(500), nullable=False, index=True)
    customer_id = db.Column(db.Integer, db.ForeignKey('customers.id'), nullable=True, index=True)
    tpid = db.Column(db.String(50), nullable=True)
    seller_name = db.Column(db.String(200), nullable=True)
    bucket = db.Column(db.String(50), nullable=False)
    
    # When was this analysis computed?
    analyzed_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    months_analyzed = db.Column(db.Integer, nullable=False)  # How many months of data used
    
    # Revenue summary
    avg_revenue = db.Column(db.Float, nullable=False)
    latest_revenue = db.Column(db.Float, nullable=False)  # Most recent final month
    
    # Analysis results
    category = db.Column(db.String(50), nullable=False)  # CHURN_RISK, RECENT_DIP, etc.
    recommended_action = db.Column(db.String(50), nullable=False)  # CHECK-IN (Urgent), etc.
    confidence = db.Column(db.String(20), nullable=False)  # LOW, MEDIUM, HIGH
    priority_score = db.Column(db.Integer, nullable=False)  # 0-100
    
    # Dollar impact
    dollars_at_risk = db.Column(db.Float, default=0.0)
    dollars_opportunity = db.Column(db.Float, default=0.0)
    
    # Statistical signals
    trend_slope = db.Column(db.Float, default=0.0)  # %/month
    last_month_change = db.Column(db.Float, default=0.0)
    last_2month_change = db.Column(db.Float, default=0.0)
    volatility_cv = db.Column(db.Float, default=0.0)
    max_drawdown = db.Column(db.Float, default=0.0)
    current_vs_max = db.Column(db.Float, default=0.0)
    current_vs_avg = db.Column(db.Float, default=0.0)
    
    # Engagement rationale (plain English)
    engagement_rationale = db.Column(db.Text, nullable=True)
    
    # For change tracking - previous analysis values
    previous_category = db.Column(db.String(50), nullable=True)
    previous_priority_score = db.Column(db.Integer, nullable=True)
    status_changed_at = db.Column(db.DateTime, nullable=True)
    
    # Relationships
    customer = db.relationship('Customer', backref='revenue_analyses')
    engagements = db.relationship('RevenueEngagement', back_populates='analysis', lazy='select')
    
    # Unique constraint: one active analysis per customer/bucket
    __table_args__ = (
        db.UniqueConstraint('customer_name', 'bucket', name='uq_analysis_customer_bucket'),
    )
    
    def __repr__(self) -> str:
        return f'<RevenueAnalysis {self.customer_name} {self.bucket}: {self.category} ({self.priority_score})>'


class RevenueConfig(db.Model):
    """User-configurable thresholds for revenue analysis."""
    __tablename__ = 'revenue_config'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    
    # Revenue gates
    min_revenue_for_outreach = db.Column(db.Integer, default=3000)
    min_dollar_impact = db.Column(db.Integer, default=1000)
    dollar_at_risk_override = db.Column(db.Integer, default=2000)
    dollar_opportunity_override = db.Column(db.Integer, default=1500)
    
    # Revenue tiers
    high_value_threshold = db.Column(db.Integer, default=25000)
    strategic_threshold = db.Column(db.Integer, default=50000)
    
    # Category thresholds
    volatile_min_revenue = db.Column(db.Integer, default=5000)
    recent_drop_threshold = db.Column(db.Float, default=-0.15)  # -15%
    expansion_growth_threshold = db.Column(db.Float, default=0.08)  # 8%
    
    # Relationships
    user = db.relationship('User', foreign_keys=[user_id])
    
    def __repr__(self) -> str:
        return f'<RevenueConfig user_id={self.user_id}>'


class RevenueEngagement(db.Model):
    """Tracks follow-up on a specific revenue recommendation.
    
    Created when you export/send recommendations to a seller.
    Each time a customer is flagged and sent out = one engagement record.
    Allows tracking history: "Flagged 3 times, here's what we did each time."
    """
    __tablename__ = 'revenue_engagements'
    
    id = db.Column(db.Integer, primary_key=True)
    analysis_id = db.Column(db.Integer, db.ForeignKey('revenue_analyses.id'), nullable=False)
    
    # When was this sent out for follow-up?
    created_at = db.Column(db.DateTime, default=utc_now, nullable=False)
    assigned_to_seller = db.Column(db.String(200), nullable=True)  # Seller name from analysis
    
    # What was the recommendation when sent? (snapshot in case analysis updates)
    category_when_sent = db.Column(db.String(50), nullable=False)
    action_when_sent = db.Column(db.String(50), nullable=False)
    rationale_when_sent = db.Column(db.Text, nullable=True)
    
    # Tracking status
    status = db.Column(db.String(20), default='pending', nullable=False)
    # pending = sent out, awaiting response
    # in_progress = seller acknowledged, working on it
    # resolved = issue addressed
    # dismissed = not actionable / false positive
    
    # What did the seller report back?
    seller_response = db.Column(db.Text, nullable=True)
    response_date = db.Column(db.DateTime, nullable=True)
    
    # Your notes on resolution
    resolution_notes = db.Column(db.Text, nullable=True)
    resolved_at = db.Column(db.DateTime, nullable=True)
    
    # Optional link to a call log if one was created from this engagement
    call_log_id = db.Column(db.Integer, db.ForeignKey('call_logs.id'), nullable=True)
    
    # Relationships
    analysis = db.relationship('RevenueAnalysis', back_populates='engagements')
    call_log = db.relationship('CallLog', backref='revenue_engagement')
    
    def __repr__(self) -> str:
        return f'<RevenueEngagement {self.id} for analysis {self.analysis_id}: {self.status}>'


# =============================================================================
# Sync Status Tracking
# =============================================================================

class SyncStatus(db.Model):
    """Tracks sync start/completion times to detect interrupted syncs.
    
    A sync is considered successfully completed only when completed_at >= started_at
    and success is True. If the user reloads mid-sync, started_at will be set but
    completed_at will be null, correctly indicating the sync didn't finish.
    """
    __tablename__ = 'sync_status'
    
    id = db.Column(db.Integer, primary_key=True)
    sync_type = db.Column(db.String(50), unique=True, nullable=False)  # 'milestones', 'accounts', etc.
    started_at = db.Column(db.DateTime, nullable=True)
    completed_at = db.Column(db.DateTime, nullable=True)
    success = db.Column(db.Boolean, nullable=True)
    items_synced = db.Column(db.Integer, nullable=True)
    details = db.Column(db.Text, nullable=True)  # JSON string for extra stats
    
    @classmethod
    def is_complete(cls, sync_type: str) -> bool:
        """Check if the given sync type has completed successfully."""
        status = cls.query.filter_by(sync_type=sync_type).first()
        if not status:
            return False
        return (
            status.success is True
            and status.completed_at is not None
            and status.started_at is not None
            and status.completed_at >= status.started_at
        )

    @classmethod
    def get_status(cls, sync_type: str) -> dict:
        """Get detailed status info for a sync type.

        Returns:
            Dict with keys:
                state: 'never_run' | 'in_progress' | 'failed' | 'incomplete' | 'complete'
                started_at: datetime or None
                completed_at: datetime or None
                items_synced: int or None
                details: str or None
        """
        status = cls.query.filter_by(sync_type=sync_type).first()
        if not status or status.started_at is None:
            return {'state': 'never_run', 'started_at': None,
                    'completed_at': None, 'items_synced': None, 'details': None}

        base = {
            'started_at': status.started_at,
            'completed_at': status.completed_at,
            'items_synced': status.items_synced,
            'details': status.details,
        }

        # Started but never completed â€” interrupted / in progress
        if status.completed_at is None:
            base['state'] = 'incomplete'
            return base

        # Completed but failed
        if not status.success:
            base['state'] = 'failed'
            return base

        # Completed successfully
        if status.completed_at >= status.started_at:
            base['state'] = 'complete'
            return base

        # Edge case: completed_at < started_at (shouldn't happen)
        base['state'] = 'incomplete'
        return base
    
    @classmethod
    def mark_started(cls, sync_type: str) -> 'SyncStatus':
        """Mark a sync as started (clears previous completion)."""
        status = cls.query.filter_by(sync_type=sync_type).first()
        if not status:
            status = cls(sync_type=sync_type)
            db.session.add(status)
        status.started_at = utc_now()
        status.completed_at = None
        status.success = None
        status.items_synced = None
        status.details = None
        db.session.commit()
        return status
    
    @classmethod
    def mark_completed(cls, sync_type: str, success: bool,
                       items_synced: int = None, details: str = None) -> 'SyncStatus':
        """Mark a sync as completed."""
        status = cls.query.filter_by(sync_type=sync_type).first()
        if not status:
            status = cls(sync_type=sync_type, started_at=utc_now())
            db.session.add(status)
        status.completed_at = utc_now()
        status.success = success
        status.items_synced = items_synced
        status.details = details
        db.session.commit()
        return status
    
    def __repr__(self) -> str:
        return f'<SyncStatus {self.sync_type} success={self.success}>'