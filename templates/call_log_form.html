{% extends "base.html" %}

{% block title %}{{ 'Edit' if call_log else 'New' }} Call Log - NoteHelper{% endblock %}

{% block extra_css %}
<!-- Quill Rich Text Editor -->
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
{% if not call_log and previous_calls %}
<style>
    /* Override container for full-width layout when showing previous calls */
    main.container {
        max-width: min(100%, 1900px) !important;
        padding-left: 2rem !important;
        padding-right: 2rem !important;
        width: 100% !important;
    }
    
    /* Previous calls section styling */
    .previous-calls-card {
        display: flex;
        flex-direction: column;
    }
    
    .previous-calls-body {
        overflow-y: auto;
    }
</style>
{% endif %}
{% endblock %}

{% block content %}

<div class="d-flex justify-content-between align-items-center mb-4">
    <h1 class="mb-0">{{ 'Edit' if call_log else 'New' }} Call Log{% if not call_log and preselect_customer %} - {{ preselect_customer.name }}{% endif %}</h1>
    <div id="draftSaveIndicator" class="text-muted small" style="opacity: 0; transition: opacity 0.3s;">
        <i class="bi bi-check-circle text-success"></i> Draft saved
    </div>
</div>

<div class="row">
    <div class="col-md-{% if not call_log and previous_calls %}6{% else %}10{% endif %}">
        <div class="card">
            <div class="card-body">
                <form method="POST" id="callLogForm">
                    <input type="hidden" name="referrer" value="{{ referrer if referrer else '' }}">
                    <div class="mb-3">
                        <label for="customer_id" class="form-label">Customer *</label>
                        <select class="form-select" id="customer_id" name="customer_id" required {% if not call_log and preselect_customer_id %}disabled{% endif %}>
                            <option value="">-- Select customer --</option>
                            {% for customer in customers %}
                                <option value="{{ customer.id }}"
                                    {% if (call_log and call_log.customer_id == customer.id) or (preselect_customer_id and preselect_customer_id == customer.id) %}selected{% endif %}>
                                    {{ customer.name }} ({{ customer.tpid }})
                                </option>
                            {% endfor %}
                        </select>
                        {% if not call_log and preselect_customer_id %}
                            <input type="hidden" name="customer_id" value="{{ preselect_customer_id }}">
                        {% endif %}
                        {% if call_log and call_log.customer and call_log.customer.seller %}
                            <div class="form-text">Seller: <strong>{{ call_log.customer.seller.name }}</strong></div>
                        {% elif preselect_customer and preselect_customer.seller %}
                            <div class="form-text">Seller: <strong>{{ preselect_customer.seller.name }}</strong></div>
                        {% endif %}
                    </div>
                    
                    <div class="mb-3">
                        <label for="call_date" class="form-label">Call Date *</label>
                        <input type="date" class="form-control" id="call_date" name="call_date" 
                               value="{% if call_log %}{{ call_log.call_date.strftime('%Y-%m-%d') }}{% else %}{{ today }}{% endif %}" 
                               required>
                    </div>
                    
                    <div class="mb-3">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <label for="topic_search" class="form-label mb-0">Topics</label>
                            {% if ai_config and ai_config.enabled %}
                            <button type="button" class="btn btn-sm btn-outline-primary" id="aiSuggestBtn">
                                <i class="bi bi-stars"></i> <span id="aiSuggestBtnText">Auto-tag with AI</span>
                            </button>
                            {% endif %}
                        </div>
                        <input type="text" class="form-control" id="topic_search" 
                               placeholder="Search and add topics..." autocomplete="off">
                        <div id="topic_dropdown" class="list-group mt-1" style="display: none; position: absolute; z-index: 1000; max-height: 200px; overflow-y: auto;"></div>
                        
                        <div id="selected_topics" class="mt-2 d-flex flex-wrap gap-2">
                            {% if call_log %}
                                {% for topic in call_log.topics %}
                                    <span class="badge bg-warning text-dark d-flex align-items-center" data-topic-id="{{ topic.id }}">
                                        <i class="bi bi-tag me-1"></i> {{ topic.name }}
                                        <button type="button" class="btn-close btn-close-white ms-2" style="font-size: 0.7rem;" onclick="removeTopic({{ topic.id }})"></button>
                                        <input type="hidden" name="topic_ids" value="{{ topic.id }}">
                                    </span>
                                {% endfor %}
                            {% endif %}
                            {% if preselect_topic_id %}
                                {% for topic in topics %}
                                    {% if topic.id == preselect_topic_id %}
                                        <span class="badge bg-warning text-dark d-flex align-items-center" data-topic-id="{{ topic.id }}">
                                            <i class="bi bi-tag me-1"></i> {{ topic.name }}
                                            <button type="button" class="btn-close btn-close-white ms-2" style="font-size: 0.7rem;" onclick="removeTopic({{ topic.id }})"></button>
                                            <input type="hidden" name="topic_ids" value="{{ topic.id }}">
                                        </span>
                                    {% endif %}
                                {% endfor %}
                            {% endif %}
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <label for="content" class="form-label">Call Notes *</label>
                        <div id="editor" style="height: 400px;">{{ call_log.content|safe if call_log else '' }}</div>
                        <textarea name="content" id="content" style="display:none;"></textarea>
                        <div class="form-text">Use rich formatting to capture call details, action items, and follow-ups</div>
                    </div>
                    
                    <div class="d-flex justify-content-between">
                        <div>
                            <button type="submit" class="btn btn-success">
                                <i class="bi bi-check-circle"></i> Save Call Log
                            </button>
                            {% if not call_log %}
                            <button type="button" class="btn btn-outline-danger ms-2" onclick="discardDraft()">
                                <i class="bi bi-trash"></i> Discard Draft
                            </button>
                            {% endif %}
                        </div>
                        <a href="{{ url_for('call_logs.call_logs_list') }}" class="btn btn-secondary">
                            <i class="bi bi-x-circle"></i> Cancel
                        </a>
                    </div>
                </form>
            </div>
        </div>
    </div>
    
    {% if not call_log and previous_calls %}
    <div class="col-md-6">
        <div class="card previous-calls-card">
            <div class="card-header">
                <h5 class="mb-0">Previous Call Logs ({{ previous_calls|length }})</h5>
            </div>
            <div class="card-body previous-calls-body">
                {% for call in previous_calls %}
                    <div class="mb-4 pb-3 {% if not loop.last %}border-bottom{% endif %}">
                        <div class="d-flex justify-content-between align-items-start mb-2">
                            <h6 class="mb-0">{{ call.call_date.strftime('%b %d, %Y') }}</h6>
                            <a href="{{ url_for('call_logs.call_log_view', id=call.id) }}" class="btn btn-sm btn-outline-secondary" target="_blank">
                                <i class="bi bi-box-arrow-up-right"></i> View
                            </a>
                        </div>
                        {% if call.topics|length > 0 %}
                            <div class="mb-2">
                                {% for topic in call.topics %}
                                    <span class="badge bg-warning text-dark"><i class="bi bi-tag"></i> {{ topic.name }}</span>
                                {% endfor %}
                            </div>
                        {% endif %}
                        <div>{{ call.content|safe }}</div>
                    </div>
                {% endfor %}
            </div>
        </div>
    </div>
    {% endif %}
</div>
{% endblock %}

{% block extra_js %}
<!-- Quill Rich Text Editor -->
<script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
<script>
// Initialize Quill editor
var quill = new Quill('#editor', {
    theme: 'snow',
    modules: {
        toolbar: [
            [{ 'header': [1, 2, 3, false] }],
            ['bold', 'italic', 'underline', 'strike'],
            [{ 'list': 'ordered'}, { 'list': 'bullet' }],
            [{ 'indent': '-1'}, { 'indent': '+1' }],
            ['link'],
            ['clean']
        ]
    }
});

// Sync editor content to hidden textarea on form submit
document.getElementById('callLogForm').onsubmit = function(e) {
    var content = document.querySelector('textarea[name=content]');
    content.value = quill.root.innerHTML;
    
    // Validation: check if content is empty (only whitespace/tags)
    var tempDiv = document.createElement('div');
    tempDiv.innerHTML = content.value;
    var textContent = tempDiv.textContent || tempDiv.innerText || '';
    
    if (textContent.trim().length === 0) {
        e.preventDefault();
        alert('Call notes cannot be empty.');
        quill.focus();
        return false;
    }
    
    return true;
};

// Topic search and selection functionality
const allTopics = [
    {% for topic in topics %}
        { id: {{ topic.id }}, name: "{{ topic.name|escape }}", description: "{{ topic.description|escape if topic.description else '' }}" },
    {% endfor %}
];

const topicSearch = document.getElementById('topic_search');
const topicDropdown = document.getElementById('topic_dropdown');
const selectedTopicsContainer = document.getElementById('selected_topics');
let currentMatches = [];
let selectedIndex = -1;

topicSearch.addEventListener('input', function() {
    const searchTerm = this.value.toLowerCase().trim();
    
    if (searchTerm.length === 0) {
        topicDropdown.style.display = 'none';
        currentMatches = [];
        selectedIndex = -1;
        return;
    }
    
    // Filter topics case-insensitively
    currentMatches = allTopics.filter(topic => 
        topic.name.toLowerCase().includes(searchTerm) && 
        !isTopicSelected(topic.id)
    );
    
    if (currentMatches.length > 0) {
        selectedIndex = 0; // Auto-select first item
        renderDropdown();
        topicDropdown.style.display = 'block';
        topicDropdown.style.width = topicSearch.offsetWidth + 'px';
    } else {
        topicDropdown.style.display = 'none';
        currentMatches = [];
        selectedIndex = -1;
    }
});

// Keyboard navigation
topicSearch.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowDown' && currentMatches.length > 0) {
        e.preventDefault();
        selectedIndex = (selectedIndex + 1) % currentMatches.length;
        renderDropdown();
    } else if (e.key === 'ArrowUp' && currentMatches.length > 0) {
        e.preventDefault();
        selectedIndex = selectedIndex <= 0 ? currentMatches.length - 1 : selectedIndex - 1;
        renderDropdown();
    } else if (e.key === 'Tab') {
        e.preventDefault();
        
        if (currentMatches.length > 0 && selectedIndex >= 0 && selectedIndex < currentMatches.length) {
            // Select existing topic from search results
            const topic = currentMatches[selectedIndex];
            addTopic(topic.id, topic.name);
        }
    } else if (e.key === 'Enter') {
        e.preventDefault();
        
        // Only create new topic on Enter if there are no matches
        if (currentMatches.length === 0) {
            const searchTerm = topicSearch.value.trim();
            if (searchTerm.length > 0) {
                createNewTopic(searchTerm);
            }
        } else if (selectedIndex >= 0 && selectedIndex < currentMatches.length) {
            // Select the highlighted topic
            const topic = currentMatches[selectedIndex];
            addTopic(topic.id, topic.name);
        }
    } else if (e.key === 'Escape') {
        topicDropdown.style.display = 'none';
        currentMatches = [];
        selectedIndex = -1;
    }
});

function renderDropdown() {
    topicDropdown.innerHTML = currentMatches.map((topic, index) => 
        `<button type="button" class="list-group-item list-group-item-action ${index === selectedIndex ? 'active' : ''}" 
            data-topic-id="${topic.id}" 
            data-topic-name="${topic.name.replace(/"/g, '&quot;')}"
            data-topic-index="${index}"
            onmouseenter="handleTopicHover(${index})"
            onclick="handleTopicClick(${topic.id}, '${topic.name.replace(/'/g, "\\'")}')">
            <i class="bi bi-tag"></i> ${topic.name}
            ${topic.description ? '<br><small class="text-muted">' + topic.description + '</small>' : ''}
        </button>`
    ).join('');
}

function handleTopicHover(index) {
    selectedIndex = index;
    // Update active class
    topicDropdown.querySelectorAll('button').forEach((btn, i) => {
        if (i === index) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });
}

function handleTopicClick(topicId, topicName) {
    addTopic(topicId, topicName);
}

// Hide dropdown when clicking outside
document.addEventListener('click', function(e) {
    // Only hide if clicking outside both the search input and the dropdown
    if (!topicSearch.contains(e.target) && !topicDropdown.contains(e.target)) {
        topicDropdown.style.display = 'none';
        currentMatches = [];
        selectedIndex = -1;
    }
});

function isTopicSelected(topicId) {
    return selectedTopicsContainer.querySelector(`[data-topic-id="${topicId}"]`) !== null;
}

function addTopic(topicId, topicName) {
    if (isTopicSelected(topicId)) return;
    
    const badge = document.createElement('span');
    badge.className = 'badge bg-warning text-dark d-flex align-items-center';
    badge.setAttribute('data-topic-id', topicId);
    badge.innerHTML = `
        <i class="bi bi-tag me-1"></i> ${topicName}
        <button type="button" class="btn-close btn-close-white ms-2" style="font-size: 0.7rem;" onclick="removeTopic(${topicId})"></button>
        <input type="hidden" name="topic_ids" value="${topicId}">
    `;
    
    selectedTopicsContainer.appendChild(badge);
    topicSearch.value = '';
    topicDropdown.style.display = 'none';
    currentMatches = [];
    selectedIndex = -1;
    topicSearch.focus(); // Keep focus on search box
    
    // Trigger debounced auto-save
    debouncedAutoSave();
}

function removeTopic(topicId) {
    const badge = selectedTopicsContainer.querySelector(`span[data-topic-id="${topicId}"]`);
    if (badge) {
        badge.remove();
        // Trigger debounced auto-save
        debouncedAutoSave();
    }
}

function createNewTopic(topicName) {
    // Show loading indicator
    topicSearch.disabled = true;
    topicSearch.placeholder = 'Creating topic...';
    
    fetch('/api/topic/create', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ name: topicName })
    })
    .then(response => response.json())
    .then(data => {
        if (data.id) {
            // Add newly created or existing topic to the list
            allTopics.push({
                id: data.id,
                name: data.name,
                description: data.description
            });
            
            // Add to selected topics
            addTopic(data.id, data.name);
            
            // Show feedback
            if (data.existed) {
                console.log('Topic already existed, added to selection');
            } else {
                console.log('New topic created and added');
            }
        }
    })
    .catch(error => {
        console.error('Error creating topic:', error);
        alert('Failed to create topic. Please try again.');
    })
    .finally(() => {
        // Reset search box
        topicSearch.disabled = false;
        topicSearch.placeholder = 'Search and add topics...';
        topicSearch.value = '';
        topicSearch.focus();
    });
}

// AI Topic Suggestion
let lastAiCallFailed = false;
let aiButtonDisabledUntil = 0;

// Show AI button if AI is enabled (no need for API call - we already have this from template)
{% if ai_config and ai_config.enabled %}
document.getElementById('aiSuggestBtn').style.display = 'block';
{% endif %}

document.getElementById('aiSuggestBtn').addEventListener('click', function() {
    const aiBtn = this;
    const btnText = document.getElementById('aiSuggestBtnText');
    const originalText = btnText.textContent;
    
    // Check if button is in cooldown
    if (Date.now() < aiButtonDisabledUntil) {
        return;
    }
    
    // Get call notes from Quill editor
    const callNotes = quill.getText().trim();
    
    if (!callNotes || callNotes.length < 10) {
        alert('Please enter some call notes first (at least 10 characters).');
        return;
    }
    
    // Disable button and show loading
    aiBtn.disabled = true;
    btnText.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Analyzing...';
    
    fetch('/api/ai/suggest-topics', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ call_notes: callNotes })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Add suggested topics that aren't already selected
            let addedCount = 0;
            data.topics.forEach(topic => {
                if (!isTopicSelected(topic.id)) {
                    addTopic(topic.id, topic.name);
                    addedCount++;
                }
            });
            
            if (addedCount > 0) {
                btnText.textContent = `Added ${addedCount} topic${addedCount > 1 ? 's' : ''}!`;
                setTimeout(() => btnText.textContent = 'Auto-tag with AI', 2000);
            } else {
                btnText.textContent = 'All suggested topics already added';
                setTimeout(() => btnText.textContent = 'Auto-tag with AI', 2000);
            }
            
            lastAiCallFailed = false;
            aiBtn.disabled = false;
        } else {
            // Handle error
            btnText.textContent = 'Error - Try again in 5s';
            lastAiCallFailed = true;
            aiButtonDisabledUntil = Date.now() + 5000;
            setTimeout(() => {
                aiBtn.disabled = false;
                btnText.textContent = originalText;
            }, 5000);
            alert('AI Error: ' + data.error);
        }
    })
    .catch(error => {
        console.error('AI request failed:', error);
        btnText.textContent = 'Error - Try again in 5s';
        lastAiCallFailed = true;
        aiButtonDisabledUntil = Date.now() + 5000;
        setTimeout(() => {
            aiBtn.disabled = false;
            btnText.textContent = originalText;
        }, 5000);
        alert('Failed to get AI suggestions. Please try again.');
    });
});

// ===== AUTO-SAVE FUNCTIONALITY =====
const DRAFT_KEY_PREFIX = 'notehelper_draft_';
const MAX_DRAFTS = 5;
const DEBOUNCE_DELAY = 1500; // 1.5 seconds after user stops typing
let autoSaveTimeout = null;
let draftRestored = false;

// Get customer-specific draft key
function getDraftKey() {
    const customerId = document.getElementById('customer_id').value;
    return customerId ? `${DRAFT_KEY_PREFIX}${customerId}` : null;
}

// Get customer name from select dropdown
function getCustomerName() {
    const customerSelect = document.getElementById('customer_id');
    const selectedOption = customerSelect.options[customerSelect.selectedIndex];
    return selectedOption ? selectedOption.textContent.trim() : '';
}

// Save draft to localStorage
function saveDraft() {
    const draftKey = getDraftKey();
    if (!draftKey) return; // Can't save without customer selected
    
    const draftData = {
        customer_id: document.getElementById('customer_id').value,
        customer_name: getCustomerName(),
        call_date: document.getElementById('call_date').value,
        content: quill.root.innerHTML,
        topics: Array.from(selectedTopicsContainer.querySelectorAll('input[name="topic_ids"]')).map(input => ({
            id: parseInt(input.value),
            name: input.closest('.badge').textContent.trim().replace('Ã—', '').trim()
        })),
        timestamp: Date.now()
    };
    
    // Only save if there's actual content
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = draftData.content;
    const textContent = (tempDiv.textContent || tempDiv.innerText || '').trim();
    
    if (textContent.length > 0 || draftData.topics.length > 0) {
        try {
            localStorage.setItem(draftKey, JSON.stringify(draftData));
            console.log('Draft auto-saved');
            showDraftSavedIndicator();
        } catch (e) {
            console.error('Failed to save draft:', e);
            // Storage quota exceeded - prune old drafts
            pruneOldDrafts();
        }
    }
}

// Show draft saved indicator with fade animation
function showDraftSavedIndicator() {
    const indicator = document.getElementById('draftSaveIndicator');
    if (!indicator) return;
    
    indicator.style.opacity = '1';
    setTimeout(() => {
        indicator.style.opacity = '0';
    }, 2000);
}

// Restore draft from localStorage
function restoreDraft() {
    const draftKey = getDraftKey();
    if (!draftKey) return false;
    
    try {
        const draftJson = localStorage.getItem(draftKey);
        if (!draftJson) return false;
        
        const draft = JSON.parse(draftJson);
        
        // Check if draft has any content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = draft.content || '';
        const textContent = (tempDiv.textContent || tempDiv.innerText || '').trim();
        
        if (textContent.length === 0 && (!draft.topics || draft.topics.length === 0)) {
            return false; // No content to restore
        }
        
        // Restore form data
        if (draft.call_date) {
            document.getElementById('call_date').value = draft.call_date;
        }
        
        if (draft.content) {
            quill.root.innerHTML = draft.content;
        }
        
        if (draft.topics && draft.topics.length > 0) {
            draft.topics.forEach(topic => {
                if (!isTopicSelected(topic.id)) {
                    addTopic(topic.id, topic.name);
                }
            });
        }
        
        return true;
    } catch (e) {
        console.error('Failed to restore draft:', e);
        return false;
    }
}

// Clear draft from localStorage
function clearDraft() {
    const draftKey = getDraftKey();
    if (!draftKey) return;
    
    try {
        localStorage.removeItem(draftKey);
        console.log('Draft cleared');
    } catch (e) {
        console.error('Failed to clear draft:', e);
    }
}

// Prune old drafts (keep only MAX_DRAFTS most recent)
function pruneOldDrafts() {
    try {
        const drafts = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(DRAFT_KEY_PREFIX)) {
                try {
                    const data = JSON.parse(localStorage.getItem(key));
                    drafts.push({ key, timestamp: data.timestamp || 0 });
                } catch (e) {
                    // Invalid draft, remove it
                    localStorage.removeItem(key);
                }
            }
        }
        
        // Sort by timestamp descending
        drafts.sort((a, b) => b.timestamp - a.timestamp);
        
        // Remove drafts beyond MAX_DRAFTS
        if (drafts.length > MAX_DRAFTS) {
            drafts.slice(MAX_DRAFTS).forEach(draft => {
                localStorage.removeItem(draft.key);
                console.log('Pruned old draft:', draft.key);
            });
        }
    } catch (e) {
        console.error('Failed to prune drafts:', e);
    }
}

// Listen for storage changes (multi-tab coordination)
window.addEventListener('storage', function(e) {
    if (e.key && e.key.startsWith(DRAFT_KEY_PREFIX)) {
        const draftKey = getDraftKey();
        if (e.key === draftKey && !draftRestored) {
            // Another tab modified our draft - reload if we haven't restored yet
            if (e.newValue) {
                console.log('Draft updated from another tab');
                const shouldRestore = confirm('A draft was updated in another tab. Reload it?');
                if (shouldRestore) {
                    restoreDraft();
                    draftRestored = true;
                }
            }
        }
    }
});

// Debounced auto-save - saves after user stops typing for DEBOUNCE_DELAY ms
function debouncedAutoSave() {
    // Clear any existing timeout
    if (autoSaveTimeout) {
        clearTimeout(autoSaveTimeout);
    }
    
    // Set new timeout to save after delay
    const customerId = document.getElementById('customer_id').value;
    if (customerId) {
        autoSaveTimeout = setTimeout(() => {
            saveDraft();
        }, DEBOUNCE_DELAY);
    }
}

// Function to start auto-save for selected customer
function startAutoSave() {
    const customerSelect = document.getElementById('customer_id');
    const customerId = customerSelect.value || customerSelect.querySelector('option[selected]')?.value;
    
    // Check for existing draft when customer changes
    if (customerId && !draftRestored) {
        const hasDraft = restoreDraft();
        if (hasDraft) {
            draftRestored = true;
            
            // Show dismissible alert
            const alertDiv = document.createElement('div');
            alertDiv.className = 'alert alert-info alert-dismissible fade show mt-3';
            alertDiv.innerHTML = `
                <i class="bi bi-info-circle"></i> <strong>Draft restored!</strong> Your unsaved changes have been recovered.
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            document.querySelector('form').insertBefore(alertDiv, document.querySelector('form').firstChild);
            
            // Auto-dismiss after 5 seconds
            setTimeout(() => {
                alertDiv.classList.remove('show');
                setTimeout(() => alertDiv.remove(), 150);
            }, 5000);
        }
    }
    
    // Set up debounced auto-save listeners if customer selected
    if (customerId) {
        // Listen to Quill text changes
        quill.on('text-change', debouncedAutoSave);
        
        // Listen to date field changes
        document.getElementById('call_date').addEventListener('input', debouncedAutoSave);
        
        console.log('Debounced auto-save enabled for customer', customerId);
    }
}

// Start auto-save when customer is selected
document.getElementById('customer_id').addEventListener('change', startAutoSave);

// Flag to prevent saving after successful submission
let formSubmittedSuccessfully = false;

// Save draft before page unload (unless form was successfully submitted)
window.addEventListener('beforeunload', function(e) {
    const customerId = document.getElementById('customer_id').value;
    if (customerId && !formSubmittedSuccessfully) {
        saveDraft();
    }
});

// Clear draft only after successful form submission
document.getElementById('callLogForm').addEventListener('submit', function(e) {
    e.preventDefault(); // Prevent default form submission
    
    const form = e.target;
    const formData = new FormData(form);
    const submitButton = form.querySelector('button[type="submit"]');
    
    // Disable submit button to prevent double submission
    submitButton.disabled = true;
    submitButton.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Saving...';
    
    // Submit via fetch so we can wait for response
    fetch(form.action, {
        method: 'POST',
        body: formData,
        redirect: 'follow' // Follow redirects automatically
    })
    .then(response => {
        console.log('Response status:', response.status, 'OK:', response.ok, 'Redirected:', response.redirected);
        if (response.ok || response.redirected) {
            // Success! Set flag to prevent beforeunload from saving
            console.log('Setting submission success flag...');
            formSubmittedSuccessfully = true;
            
            // Stop auto-save first, then clear the draft
            console.log('Stopping auto-save...');
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
                autoSaveTimeout = null;
            }
            console.log('Clearing draft before redirect...');
            clearDraft();
            console.log('Draft cleared, redirecting to:', response.url);
            // Redirect to the final URL (after any server redirects)
            window.location.href = response.url;
        } else {
            // Server returned an error - keep the draft
            throw new Error('Form submission failed');
        }
    })
    .catch(error => {
        console.error('Form submission error:', error);
        alert('Failed to save call log. Your draft has been preserved. Please try again.');
        // Re-enable submit button
        submitButton.disabled = false;
        submitButton.innerHTML = '<i class="bi bi-save"></i> Save Call Log';
    });
});

// Discard draft function
function discardDraft() {
    if (confirm('Discard this draft? This will clear all unsaved changes and cannot be undone.')) {
        clearDraft();
        if (autoSaveTimeout) {
            clearTimeout(autoSaveTimeout);
        }
        
        // Clear the form
        quill.setContents([]);
        document.getElementById('call_date').value = '';
        document.querySelectorAll('.badge[data-topic-id]').forEach(badge => badge.remove());
        
        // Redirect back to call logs list
        window.location.href = '{{ url_for("call_logs.call_logs_list") }}';
    }
}

// Set current date as default if creating new call log
{% if not call_log %}
document.addEventListener('DOMContentLoaded', function() {
    var now = new Date();
    var year = now.getFullYear();
    var month = String(now.getMonth() + 1).padStart(2, '0');
    var day = String(now.getDate()).padStart(2, '0');
    document.getElementById('call_date').value = year + '-' + month + '-' + day;
    
    // Initialize auto-save if customer is preselected
    startAutoSave();
    
    {% if previous_calls %}
    // Match previous calls card height to new call log card height
    function matchCardHeights() {
        const newCallCard = document.querySelector('.col-md-6:first-child .card');
        const previousCallsCard = document.querySelector('.previous-calls-card');
        const previousCallsBody = document.querySelector('.previous-calls-body');
        
        if (newCallCard && previousCallsCard && previousCallsBody) {
            const newCallHeight = newCallCard.offsetHeight;
            previousCallsCard.style.height = newCallHeight + 'px';
            
            // Calculate available height for scrollable body
            const cardHeader = previousCallsCard.querySelector('.card-header');
            const headerHeight = cardHeader ? cardHeader.offsetHeight : 0;
            const bodyPadding = 32; // Card body padding
            previousCallsBody.style.maxHeight = (newCallHeight - headerHeight - bodyPadding) + 'px';
        }
    }
    
    // Match heights on load and when Quill editor is initialized
    matchCardHeights();
    setTimeout(matchCardHeights, 100); // Retry after Quill loads
    window.addEventListener('resize', matchCardHeights);
    {% endif %}
});
{% endif %}
</script>
{% endblock %}










