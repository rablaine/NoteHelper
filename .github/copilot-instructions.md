# Copilot Instructions

## Project Overview

**Project Name:** NoteHelper

**Description:** A note-taking application for Azure technical sellers to capture and retrieve customer call notes. Enables searching and filtering notes by customer, seller, technologies discussed, and other criteria.

**Target Users:** Azure technical sellers and their teammates

## Technology Stack

**Language(s):** Python 3.13

**Framework(s):** Flask

**Database:** SQLite

**Key Libraries/Packages:**
- Flask - Web framework
- Bootstrap 5 - UI components and styling
- SQLAlchemy - Database ORM (with custom idempotent migrations)
- python-dotenv - Environment variable management
- pytest - Testing framework

**Build/Package Tools:** pip, venv

## Project Structure

**Phase 1 (Current): Single-File Structure**
```
/
├── app.py              - Main Flask application (routes, models, logic)
├── templates/          - Jinja2 HTML templates
├── static/             - CSS, JS, images
│   ├── css/
│   └── js/
├── tests/              - pytest test files
├── .env                - Environment variables (not committed)
└── requirements.txt    - Python dependencies
```

**Phase 2 (Future): Blueprint Structure**
```
/app
├── __init__.py         - Flask app factory
├── models.py           - Database models
├── routes/
│   ├── customers.py    - Customer blueprint
│   ├── notes.py        - Notes blueprint
│   └── search.py       - Search blueprint
├── auth/
│   ├── flask_login.py  - Username/password auth
│   └── azure_oauth.py  - Azure AD OAuth (optional)
├── templates/
└── static/
/tests
```

## Coding Standards & Best Practices

### Code Style
- Follow PEP 8 style guide for Python code
- Use type hints for function parameters and return values
- Use 4 spaces for indentation
- Maximum line length: 100 characters
- Use docstrings for all functions, classes, and modules

### Naming Conventions
- **Files:** snake_case (e.g., `customer_routes.py`, `note_model.py`)
- **Variables:** snake_case (e.g., `customer_name`, `note_content`)
- **Constants:** UPPER_SNAKE_CASE (e.g., `DATABASE_URL`, `MAX_NOTE_LENGTH`)
- **Functions:** snake_case with verb prefixes (e.g., `get_customer`, `create_note`, `search_by_tag`)
- **Classes:** PascalCase (e.g., `Customer`, `Note`, `User`)
- **Database tables:** snake_case plural (e.g., `customers`, `notes`, `tags`)

### Code Organization
- Start with single-file app.py, refactor to blueprints when file exceeds ~300 lines
- Keep database models in separate section or file
- Group related routes together with clear comments
- Keep functions focused and under 50 lines when possible
- Extract magic numbers and strings into constants at top of file
- Separate business logic from route handlers when complexity grows

### Error Handling
- Use try-except blocks for database operations
- Log errors with context (use Python logging module)
- Return user-friendly error messages in templates
- Handle database constraint violations gracefully
- Use Flask error handlers for 404, 500, etc.

### Testing
- Use pytest for all tests
- **Write tests as you implement features** - Don't wait until later
- Write unit tests for business logic and database operations
- Use Flask test client for route testing
- Tests use isolated SQLite database (configured in `tests/conftest.py`)
- Never run tests against production database
- Aim for 70%+ code coverage
- Test file naming: `test_*.py` or `*_test.py`
- **Run tests before committing** - Ensure all tests pass with `pytest tests/`
- Add tests for any bugs discovered to prevent regression

## Architecture Patterns

**Design Pattern(s):** MVC (Model-View-Controller) pattern with Flask
- Models: SQLAlchemy ORM classes
- Views: Jinja2 templates
- Controllers: Flask route handlers

**State Management:** Single-user mode (no authentication required)

**API Design:** Server-rendered templates with Jinja2 (not REST API)
- Use POST for data modifications
- Use GET for queries and searches

**Database Migrations:** Custom idempotent migrations (NOT Flask-Migrate/Alembic)
- Located in `app/migrations.py`
- Runs automatically on every deployment via `startup.sh`
- Safe to run multiple times - checks before making changes
- `db.create_all()` creates new tables (never drops existing)
- Custom migrations handle `ALTER TABLE` operations idempotently
- To add a new migration:
  1. Add the column/change to the model in `models.py`
  2. Add a migration check in `app/migrations.py` using helper functions
  3. Test locally, then deploy - migration runs automatically
- **NEVER use DROP TABLE or DROP COLUMN without explicit data backup**

## Dependencies & Environment

**Required Environment Variables:**
```
DATABASE_URL=sqlite:///data/notehelper.db
SECRET_KEY=your-secret-key-here
FLASK_ENV=development
FLASK_DEBUG=True
```

**Prerequisites:**
- Python 3.13+
- pip and venv

## Development Workflow

**Setup:**
```powershell
# Create virtual environment
python -m venv venv
.\venv\Scripts\Activate.ps1

# Install dependencies
pip install -r requirements.txt

# Set up environment
cp .env.example .env
# Edit .env if needed (database auto-creates on first run)
```

**Running Locally:**
```powershell
.\venv\Scripts\Activate.ps1
python app.py
# or
flask run
```

**Testing:**
```powershell
pytest
pytest --cov=app tests/  # with coverage
```

## Documentation Standards

- Use docstrings for all functions, classes, and modules (Google style preferred)
- Document complex database queries with inline comments
- Keep README.md updated with setup instructions and features
- Document environment variables in .env.example
- Add comments explaining business logic, not obvious code

## Security Considerations

- Never commit .env file or secrets to Git
- Use SQLAlchemy ORM to prevent SQL injection (no raw SQL)
- Sanitize user input before displaying in templates

## Performance Guidelines

- Add database indexes on frequently queried columns (customer_id, tags, created_at)
- Use pagination for large result sets
- Eager load relationships to avoid N+1 queries
- Minimize Bootstrap JavaScript usage (only include what's needed)
- Use Flask caching for expensive queries if needed

## Environments

**Development Environment:**
- Local machine running Flask development server
- Local SQLite database (data/notehelper.db)
- Environment: `FLASK_ENV=development`, `FLASK_DEBUG=True`
- Used for developing and testing new features
- Safe to experiment and break things

**Production Environment:**
- Docker container running locally or on server
- SQLite database (persisted in mounted `data/` volume)
- Container images built automatically via GitHub Actions on push to `main` branch
- Pull latest image with: `docker pull ghcr.io/rablaine/notehelper:latest`
- Real user data - handle with care

## Git & Version Control

**Branching Strategy:** Feature branches (main builds Docker images)
- **ALWAYS create feature branches for new work** - Never commit directly to `main`
- `main` branch triggers Docker image build via GitHub Actions
- Create feature branches from `main` for all changes
- Merge back to `main` only when feature is complete and tested

**Branch Naming:** When attempting to commit to `main`, stop and prompt user for feature branch name
- Ask: "What should we call this feature branch?"
- Suggested format: `feature/short-description` or `fix/bug-description`
- Examples: `feature/export-import`, `fix/admin-permissions`, `feature/email-fields`

**Commit Message Format:** Conventional Commits
- `feat:` - New feature
- `fix:` - Bug fix
- `docs:` - Documentation changes
- `refactor:` - Code refactoring
- `test:` - Test additions or changes

**Development Workflow:**
1. Create feature branch: `git checkout -b feature/your-feature-name`
2. Write code and corresponding tests together
3. Run `pytest tests/` to verify all tests pass
4. **Prompt user to manually test new features or bug fixes** - Before committing, always ask the user to test the changes in the running app to verify everything works as expected
5. Commit to feature branch with descriptive message
6. **Wait for user confirmation** before merging to `main`
7. When user says ready: merge to `main` with `--no-ff` and push (triggers Docker image build)
   - **Always use `git merge --no-ff`** to preserve feature branch history

**Merge to Production Checklist:**
- All tests passing (`pytest tests/`)
- User has manually tested the feature
- User explicitly confirms "ready to deploy" or "merge to main"
- Code follows PEP 8 standards
- No secrets or .env file committed
- Tests included for new features or bug fixes

## UI/UX Conventions

**Visual Styling:**
- **Sellers:** Always display as badge tags with `bg-primary` styling and person icon (`<i class="bi bi-person"></i>`), unless used in page headers/titles
  - Example: `<a href="{{ url_for('seller_view', id=seller.id) }}" class="badge bg-primary text-decoration-none"><i class="bi bi-person"></i> {{ seller.name }}</a>`
- **Territories:** Always display as badge tags with `bg-info text-dark` styling and location icon (`<i class="bi bi-geo-alt"></i>`), unless used in page headers/titles
  - Example: `<a href="{{ url_for('territory_view', id=territory.id) }}" class="badge bg-info text-dark text-decoration-none"><i class="bi bi-geo-alt"></i> {{ territory.name }}</a>`
- **Topics:** Display as badge tags with `bg-warning text-dark` styling and tag icon (`<i class="bi bi-tag"></i>`)
- Maintain consistent badge styling across all views for visual parity

## Communication Style

**Tone & Personality:**
- Be chill and conversational, like you're pair programming with a friend
- Embrace a neurodivergent coding style - hyperfocus on details when they matter, but don't overthink the simple stuff
- Modern slang is fine when it flows naturally, but never force it - if it feels like you're trying too hard, just speak normally
- Appreciate good code the way gamers appreciate a clean speedrun - efficiency is satisfying
- When explaining things, keep it real and straightforward - no corporate speak or needless formality
- If something is genuinely fire or straight up broken, just say it
- Channel that "it's 2am and the code finally works" energy when celebrating successful changes, but only when it's actually earned
- The personality should be subtle background flavor, not the main character - focus on being helpful first, personality second

## Additional Notes

**Development Phases:**
- **Phase 1 (Complete):** Single-user local deployment mode
- **Phase 2 (Future):** Refactor to blueprints when complexity grows
- **Phase 3 (Optional):** Add multi-user authentication if needed

**Key Features:**
- Create/edit/delete notes (call logs)
- Tag notes with technologies, customers, sellers, territories
- Search and filter notes by multiple criteria
- Associate notes with customer accounts
- Track who created each note and when
- Data import/export for backup and migration (JSON and CSV formats)
- User preferences (dark mode, view options)
- Clickable UI elements throughout for improved navigation

**Open Source:**
- This project is open source and intended to be easy for others to contribute to
- Write clear, self-documenting code
- Prioritize simplicity and maintainability over clever solutions

---

**Last Updated:** November 21, 2025
